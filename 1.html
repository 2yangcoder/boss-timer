<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ğŸ”¥ Boss åˆ·æ–°å€’è®¡æ—¶å™¨</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif;
    }
    
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --danger: #ef4444;
      --success: #10b981;
      --warning: #f59e0b;
      --light: #f8fafc;
      --dark: #1e293b;
      --gray: #64748b;
      --light-gray: #e2e8f0;
      --card-bg: #ffffff;
      --shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 4px 6px -2px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.05);
    }
    
    body {
      background: linear-gradient(135deg, #f0f9ff 0%, #e6f3ff 100%);
      color: var(--dark);
      line-height: 1.4;
      padding: 12px;
      min-height: 100vh;
      font-size: 13px;
    }
    
    .container {
      max-width: 1000px;
      margin: 0 auto;
    }
    
    .header {
      text-align: center;
      margin-bottom: 16px;
      padding: 12px 0;
    }
    
    .header h1 {
      font-size: 1.6rem;
      font-weight: 800;
      background: linear-gradient(45deg, var(--primary), #8b5cf6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 4px;
    }
    
    .current-time {
      background: var(--card-bg);
      padding: 8px 16px;
      border-radius: 12px;
      text-align: center;
      margin: 12px 0;
      box-shadow: var(--shadow);
      font-weight: 600;
      color: var(--primary-dark);
      font-size: 12px;
    }
    
    .boss-list {
      background: var(--card-bg);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: var(--shadow-lg);
    }
    
    .list-header {
      padding: 12px 16px;
      background: var(--primary);
      color: white;
      font-weight: 700;
      font-size: 1rem;
    }
    
    .boss-item {
      padding: 12px 16px;
      border-bottom: 1px solid var(--light-gray);
      display: grid;
      grid-template-columns: 1fr auto auto;
      gap: 12px;
      align-items: center;
    }
    
    .boss-item:last-child {
      border-bottom: none;
    }
    
    .boss-info {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }
    
    .boss-header {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .boss-category {
      font-weight: 700;
      font-size: 0.85rem;
      padding: 2px 6px;
      border-radius: 4px;
      background: rgba(99, 102, 241, 0.1);
      color: var(--primary-dark);
    }
    
    .boss-category.ä¸šç« {
      background: rgba(239, 68, 68, 0.1);
      color: var(--danger);
    }
    
    .boss-category.æµ·åº• {
      background: rgba(59, 130, 246, 0.1);
      color: #3b82f6;
    }
    
    .boss-name-config {
      font-weight: 600;
      color: var(--dark);
      font-size: 1rem;
    }
    
    .last-kill {
      font-size: 0.8rem;
      color: var(--warning);
    }
    
    .accuracy-indicator {
      font-size: 0.7rem;
      font-weight: bold;
      padding: 1px 4px;
      border-radius: 3px;
      margin-left: 4px;
    }
    
    .accuracy-estimate {
      background: rgba(245, 158, 11, 0.2);
      color: var(--warning);
    }
    
    .accuracy-accurate {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
    }
    
    .refresh-countdown {
      display: flex;
      flex-direction: column;
      gap: 3px;
      text-align: right;
      min-width: 100px;
    }
    
    .refresh-time {
      font-size: 0.85rem;
      color: var(--success);
      font-weight: 600;
    }
    
    .countdown {
      font-size: 1rem;
      font-weight: 800;
      color: var(--primary-dark);
    }
    
    .countdown.warning {
      color: var(--danger);
      animation: pulse 2s infinite;
    }
    
    .countdown.expired {
      color: var(--danger);
    }
    
    .countdown.unknown {
      color: var(--gray);
    }
    
    .actions {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
    }
    
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--gray);
    }
    
    .empty-state h3 {
      font-size: 1.1rem;
      margin-bottom: 6px;
      color: var(--dark);
    }
    
    /* æ‰‹æœºç«¯ä¼˜åŒ– */
    @media (max-width: 768px) {
      .header h1 {
        font-size: 1.4rem;
      }
      
      .boss-item {
        grid-template-columns: 1fr;
        gap: 12px;
      }
      
      .refresh-countdown {
        text-align: left;
        min-width: auto;
      }
      
      .actions {
        flex-direction: row;
        justify-content: flex-end;
        align-items: center;
        gap: 8px;
      }
      
      .btn {
        width: auto;
        padding: 4px 10px;
        font-size: 0.8rem;
      }
    }
    
    @media (max-width: 480px) {
      body {
        padding: 8px;
        font-size: 12px;
      }
      
      .header h1 {
        font-size: 1.3rem;
      }
      
      .boss-item {
        padding: 10px 12px;
      }
      
      .countdown {
        font-size: 0.95rem;
      }
      
      .actions {
        flex-wrap: wrap;
      }
      
      .boss-name-config {
        font-size: 0.95rem;
      }
      
      .refresh-time {
        font-size: 0.8rem;
      }
    }
    
    .btn {
      padding: 6px 12px;
      border: none;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 70px;
      text-align: center;
    }
    
    .btn-primary {
      background: var(--primary);
      color: white;
    }
    
    .btn-primary:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }
    
    .btn-warning {
      background: var(--warning);
      color: white;
    }
    
    .btn-warning:hover {
      background: #d97706;
      transform: translateY(-1px);
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }
    
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }
    
    .modal-content {
      background-color: var(--card-bg);
      margin: 15% auto;
      padding: 20px;
      border-radius: 16px;
      width: 90%;
      max-width: 450px;
      box-shadow: var(--shadow-lg);
      font-size: 13px;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    
    .modal-title {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--dark);
    }
    
    .close {
      color: var(--gray);
      font-size: 1.3rem;
      font-weight: bold;
      cursor: pointer;
    }
    
    .close:hover {
      color: var(--dark);
    }
    
    .modal-body {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
      color: var(--dark);
      font-size: 0.9rem;
    }
    
    .form-control {
      width: 100%;
      padding: 8px 12px;
      border: 2px solid var(--light-gray);
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s ease;
      background: var(--light);
    }
    
    .form-control:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
    }
    
    .radio-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .radio-option {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .radio-option input {
      margin: 0;
    }
    
    .btn-success {
      background: var(--success);
      color: white;
      padding: 8px 16px;
      font-size: 0.9rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .btn-success:hover {
      background: #059669;
      transform: translateY(-1px);
    }
    
    .data-management {
      display: flex;
      gap: 8px;
      margin: 12px 0;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .data-management .btn {
      min-width: 100px;
      font-size: 0.8rem;
      padding: 4px 8px;
    }
    
    .btn-danger {
      background: var(--danger);
      color: white;
    }
    
    .btn-danger:hover {
      background: #dc2626;
      transform: translateY(-1px);
    }
    
    .import-textarea {
      width: 100%;
      height: 120px;
      padding: 8px 12px;
      border: 1px solid var(--light-gray);
      border-radius: 8px;
      font-family: monospace;
      font-size: 0.8rem;
      resize: vertical;
      background: var(--light);
    }
    
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 16px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Boss åˆ·æ–°å€’è®¡æ—¶å™¨</h1>
    </div>
    
    <div class="current-time" id="currentTime">å½“å‰æ—¶é—´ï¼šåŠ è½½ä¸­...</div>
    
    <div class="data-management">
      <button class="btn btn-primary" onclick="exportData()">å¯¼å‡ºæ•°æ®</button>
      <button class="btn btn-warning" onclick="showImportModal()">å¯¼å…¥æ•°æ®</button>
      <button class="btn btn-danger" onclick="showResetModal()">é‡ç½®æ•°æ®</button>
    </div>
    
    <div class="boss-list">
      <div class="list-header">Boss åˆ—è¡¨</div>
      <div id="bossListContent">
        <div class="empty-state">
          <h3>æš‚æ—  Boss æ•°æ®</h3>
          <p>æ­£åœ¨åŠ è½½é¢„è®¾ Boss æ•°æ®...</p>
        </div>
      </div>
    </div>
  </div>

  <!-- æ—¶é—´è®°å½•æ¨¡æ€æ¡† -->
  <div id="timeModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">æ‰‹åŠ¨è®°å½•å‡»æ€æ—¶é—´</div>
        <span class="close" onclick="closeModal()">&times;</span>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="modalDateTime">æ—¶é—´</label>
          <input type="datetime-local" id="modalDateTime" class="form-control" />
        </div>
        <div class="form-group">
          <label>æ—¶é—´ç²¾åº¦</label>
          <div class="radio-group">
            <div class="radio-option">
              <input type="radio" id="modalAccuracyAccurate" name="modalAccuracy" value="accurate" checked>
              <label for="modalAccuracyAccurate">å‡†</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="modalAccuracyEstimate" name="modalAccuracy" value="estimate">
              <label for="modalAccuracyEstimate">ä¼°</label>
            </div>
          </div>
        </div>
        <button class="btn-success" onclick="saveModalTime()">ç¡®å®š</button>
      </div>
    </div>
  </div>

  <!-- æ•°æ®å¯¼å…¥æ¨¡æ€æ¡† -->
  <div id="importModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">å¯¼å…¥æ•°æ®</div>
        <span class="close" onclick="closeImportModal()">&times;</span>
      </div>
      <div class="modal-body">
        <p>è¯·ç²˜è´´ä¹‹å‰å¯¼å‡ºçš„JSONæ•°æ®ï¼š</p>
        <textarea id="importData" class="import-textarea" placeholder="ç²˜è´´JSONæ•°æ®..."></textarea>
        <div class="modal-footer">
          <button class="btn btn-primary" onclick="importData()">å¯¼å…¥</button>
          <button class="btn" onclick="closeImportModal()">å–æ¶ˆ</button>
        </div>
      </div>
    </div>
  </div>

  <!-- æ•°æ®é‡ç½®æ¨¡æ€æ¡† -->
  <div id="resetModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-title">é‡ç½®æ•°æ®</div>
        <span class="close" onclick="closeResetModal()">&times;</span>
      </div>
      <div class="modal-body">
        <p style="color: var(--danger); font-weight: 600;">è­¦å‘Šï¼šæ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰æ•°æ®ï¼ŒåŒ…æ‹¬BOSSé…ç½®å’Œå‡»æ€è®°å½•ï¼</p>
        <p>è¯·ç¡®è®¤æ˜¯å¦è¦ç»§ç»­ï¼Ÿ</p>
        <div class="modal-footer">
          <button class="btn btn-danger" onclick="resetData()">ç¡®è®¤é‡ç½®</button>
          <button class="btn" onclick="closeResetModal()">å–æ¶ˆ</button>
        </div>
      </div>
    </div>
  </div>

  <!-- å¼•å…¥é…ç½®å’ŒæœåŠ¡å™¨æ•°æ®ç®¡ç† -->
  <script src="config.js"></script>
  <script src="server-data.js"></script>

  <script>
    // æ•°æ®å­˜å‚¨ç®¡ç†æ¨¡å—
    const DataStorage = {
      // å­˜å‚¨é”®å
      STORAGE_KEYS: {
        BOSS_CONFIGS: 'boss_timer_boss_configs',
        KILL_RECORDS: 'boss_timer_kill_records',
        DATA_VERSION: 'boss_timer_data_version'
      },
      
      // å½“å‰æ•°æ®ç‰ˆæœ¬
      CURRENT_VERSION: '1.0.0',
      
      // åˆå§‹åŒ–æ•°æ®
      initData() {
        // æ£€æŸ¥æ•°æ®ç‰ˆæœ¬
        const storedVersion = localStorage.getItem(this.STORAGE_KEYS.DATA_VERSION);
        if (!storedVersion) {
          // é¦–æ¬¡ä½¿ç”¨ï¼Œåˆå§‹åŒ–é»˜è®¤æ•°æ®
          this.migrateToCurrentVersion();
        } else if (storedVersion !== this.CURRENT_VERSION) {
          // ç‰ˆæœ¬ä¸åŒ¹é…ï¼Œæ‰§è¡Œæ•°æ®è¿ç§»
          this.migrateData(storedVersion);
        }
      },
      
      // æ•°æ®è¿ç§»
      migrateData(oldVersion) {
        console.log(`æ•°æ®è¿ç§»ä¸­: ${oldVersion} -> ${this.CURRENT_VERSION}`);
        // è¿™é‡Œå¯ä»¥æ·»åŠ ç‰ˆæœ¬è¿ç§»é€»è¾‘
        this.migrateToCurrentVersion();
      },
      
      // è¿ç§»åˆ°å½“å‰ç‰ˆæœ¬
      migrateToCurrentVersion() {
        // åˆå§‹åŒ–é»˜è®¤BOSSé…ç½®
        const defaultBosses = [
          { id: 1, category: "æµ·åº•", name: "å››ä¸€", interval: 6, delay: 0, lastKillTime: null, accuracy: null },
          { id: 2, category: "æµ·åº•", name: "äº”ä¸€", interval: 6, delay: 0, lastKillTime: null, accuracy: null },
          { id: 3, category: "æµ·åº•", name: "é¾™ç‹", interval: 6, delay: 0, lastKillTime: null, accuracy: null },
          { id: 4, category: "æµ·åº•", name: "æµ·é­”", interval: 8, delay: 2, lastKillTime: null, accuracy: null },
          { id: 5, category: "æµ·åº•", name: "èˆ¹é•¿", interval: 8, delay: 0, lastKillTime: null, accuracy: null },
          { id: 6, category: "ä¸šç«", name: "ç¥é©¹", interval: 6, delay: 0, lastKillTime: null, accuracy: null },
          { id: 7, category: "ä¸šç«", name: "é­”å›", interval: 6, delay: 0, lastKillTime: null, accuracy: null },
          { id: 8, category: "ä¸šç«", name: "å›šç¬¼", interval: 8, delay: 0, lastKillTime: null, accuracy: null },
          { id: 9, category: "å…¶ä»–", name: "ç¥–ç›", interval: 3, delay: 2, lastKillTime: null, accuracy: null },
          { id: 10, category: "å…¶ä»–", name: "è€ç‰›", interval: 4, delay: 0, lastKillTime: null, accuracy: null },
          { id: 11, category: "å…¶ä»–", name: "é­”ç‹", interval: 6, delay: 120, lastKillTime: null, accuracy: null },
          { id: 12, category: "å…¶ä»–", name: "æ¯’é¾™", interval: 24, delay: 0, lastKillTime: null, accuracy: null }
        ];
        
        this.saveBossConfigs(defaultBosses);
        this.saveKillRecords([]);
        localStorage.setItem(this.STORAGE_KEYS.DATA_VERSION, this.CURRENT_VERSION);
      },
      
      // BOSSé…ç½®ç®¡ç†
      saveBossConfigs(bosses) {
        try {
          localStorage.setItem(this.STORAGE_KEYS.BOSS_CONFIGS, JSON.stringify(bosses));
          return true;
        } catch (e) {
          console.error('ä¿å­˜BOSSé…ç½®å¤±è´¥:', e);
          return false;
        }
      },
      
      getBossConfigs() {
        try {
          const data = localStorage.getItem(this.STORAGE_KEYS.BOSS_CONFIGS);
          return data ? JSON.parse(data) : [];
        } catch (e) {
          console.error('è¯»å–BOSSé…ç½®å¤±è´¥:', e);
          return [];
        }
      },
      
      // å‡»æ€è®°å½•ç®¡ç†
      saveKillRecords(records) {
        try {
          localStorage.setItem(this.STORAGE_KEYS.KILL_RECORDS, JSON.stringify(records));
          return true;
        } catch (e) {
          console.error('ä¿å­˜å‡»æ€è®°å½•å¤±è´¥:', e);
          return false;
        }
      },
      
      getKillRecords() {
        try {
          const data = localStorage.getItem(this.STORAGE_KEYS.KILL_RECORDS);
          return data ? JSON.parse(data) : [];
        } catch (e) {
          console.error('è¯»å–å‡»æ€è®°å½•å¤±è´¥:', e);
          return [];
        }
      },
      
      // æ·»åŠ å‡»æ€è®°å½•
      addKillRecord(bossId, killTime, accuracy) {
        const records = this.getKillRecords();
        const newRecord = {
          id: Date.now(),
          bossId: bossId,
          killTime: killTime,
          accuracy: accuracy,
          timestamp: new Date().toISOString()
        };
        records.push(newRecord);
        
        // åªä¿ç•™æœ€è¿‘1000æ¡è®°å½•ï¼Œé¿å…å­˜å‚¨è¿‡å¤§
        if (records.length > 1000) {
          records.splice(0, records.length - 1000);
        }
        
        return this.saveKillRecords(records);
      },
      
      // è·å–æŒ‡å®šBOSSçš„å‡»æ€è®°å½•
      getKillRecordsByBoss(bossId) {
        const records = this.getKillRecords();
        return records.filter(record => record.bossId === bossId)
                     .sort((a, b) => new Date(b.killTime) - new Date(a.killTime));
      },
      
      // è·å–æœ€è¿‘ä¸€æ¬¡å‡»æ€è®°å½•
      getLastKillRecord(bossId) {
        const records = this.getKillRecordsByBoss(bossId);
        return records.length > 0 ? records[0] : null;
      },
      
      // æ•°æ®å¤‡ä»½å’Œæ¢å¤
      exportData() {
        const data = {
          version: this.CURRENT_VERSION,
          timestamp: new Date().toISOString(),
          bossConfigs: this.getBossConfigs(),
          killRecords: this.getKillRecords()
        };
        return JSON.stringify(data, null, 2);
      },
      
      importData(jsonData) {
        try {
          const data = JSON.parse(jsonData);
          
          // éªŒè¯æ•°æ®æ ¼å¼
          if (!data.bossConfigs || !data.killRecords) {
            throw new Error('æ•°æ®æ ¼å¼ä¸æ­£ç¡®');
          }
          
          // å¯¼å…¥æ•°æ®
          this.saveBossConfigs(data.bossConfigs);
          this.saveKillRecords(data.killRecords);
          
          return true;
        } catch (e) {
          console.error('å¯¼å…¥æ•°æ®å¤±è´¥:', e);
          return false;
        }
      },
      
      // æ¸…ç©ºæ‰€æœ‰æ•°æ®
      clearAllData() {
        localStorage.removeItem(this.STORAGE_KEYS.BOSS_CONFIGS);
        localStorage.removeItem(this.STORAGE_KEYS.KILL_RECORDS);
        localStorage.removeItem(this.STORAGE_KEYS.DATA_VERSION);
      }
    };

    // å…¨å±€å˜é‡
    let bosses = [];
    let currentEditingBossId = null;
    
    // æ•°æ®åŠ è½½å’ŒåŒæ­¥å‡½æ•°
    async function loadData() {
      try {
        // ä»æœåŠ¡å™¨æˆ–æœ¬åœ°åŠ è½½BOSSé…ç½®
        const serverBosses = await window.ServerDataManager.getBossConfigs();
        
        if (serverBosses.length > 0) {
          // ä¸ºæ¯ä¸ªBOSSåŠ è½½æœ€åå‡»æ€æ—¶é—´
          for (let boss of serverBosses) {
            const lastKillTime = await window.ServerDataManager.getLastKillTime(boss.id);
            boss.lastKillTime = lastKillTime;
            // ä»æœ€åä¸€æ¡è®°å½•è·å–ç²¾åº¦
            if (lastKillTime) {
              const lastRecord = await window.ServerDataManager.getKillRecords(boss.id);
              if (lastRecord.length > 0) {
                boss.accuracy = lastRecord[0].accuracy;
              }
            }
          }
          
          bosses = serverBosses;
        } else {
          // ä½¿ç”¨æœ¬åœ°å­˜å‚¨ä½œä¸ºé™çº§æ–¹æ¡ˆ
          bosses = DataStorage.getBossConfigs();
        }
        
        renderBossList();
        
        // å¦‚æœæ˜¯æœåŠ¡å™¨æ¨¡å¼ï¼Œå¼€å§‹è‡ªåŠ¨åŒæ­¥
        if (window.ServerDataManager.isConnected) {
          window.ServerDataManager.startAutoSync();
        }
        
      } catch (error) {
        console.error('æ•°æ®åŠ è½½å¤±è´¥:', error);
        // é™çº§åˆ°æœ¬åœ°å­˜å‚¨
        DataStorage.initData();
        bosses = DataStorage.getBossConfigs();
        renderBossList();
      }
    }
    
    // æœåŠ¡å™¨æ•°æ®å˜æ›´å›è°ƒ
    window.onServerDataChange = function(table, payload) {
      console.log('æœåŠ¡å™¨æ•°æ®å˜æ›´ï¼Œé‡æ–°åŠ è½½æ•°æ®');
      loadData();
    };
    
    // æ›´æ–°æœ¬åœ°æ•°æ®çš„å›è°ƒ
    window.updateLocalData = function(serverBosses, serverRecords) {
      // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´æ™ºèƒ½çš„æ•°æ®åˆå¹¶é€»è¾‘
      bosses = serverBosses;
      renderBossList();
    };

    // è®¡ç®—åˆ·æ–°æ—¶é—´
    function calculateRefreshTime(boss) {
      if (!boss.lastKillTime) {
        return { refreshTime: null, hasRange: false };
      }
      
      const lastKill = new Date(boss.lastKillTime);
      const intervalMs = boss.interval * 60 * 60 * 1000; // å°æ—¶è½¬æ¯«ç§’
      
      if (boss.delay === 0) {
        // æ— å»¶è¿Ÿï¼Œç›´æ¥è¿”å›ç²¾ç¡®åˆ·æ–°æ—¶é—´
        const refreshTime = new Date(lastKill.getTime() + intervalMs);
        return { refreshTime, hasRange: false };
      } else {
        // æœ‰å»¶è¿Ÿï¼Œè¿”å›æ—¶é—´èŒƒå›´
        const delayMs = boss.delay * 60 * 1000; // åˆ†é’Ÿè½¬æ¯«ç§’
        const earliest = new Date(lastKill.getTime() + intervalMs - delayMs);
        const latest = new Date(lastKill.getTime() + intervalMs + delayMs);
        return { earliest, latest, hasRange: true };
      }
    }

    // è·å–å½“å‰å€’è®¡æ—¶çŠ¶æ€
    function getCurrentCountdownStatus(boss) {
      if (!boss.lastKillTime) {
        return { countdown: 'æœªå‡»æ€', status: 'unknown', nextRefresh: null };
      }
      
      const refreshInfo = calculateRefreshTime(boss);
      const now = new Date();
      
      if (!refreshInfo.hasRange) {
        // ç²¾ç¡®æ—¶é—´
        if (now < refreshInfo.refreshTime) {
          const diff = refreshInfo.refreshTime - now;
          const totalSeconds = Math.floor(diff / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const status = minutes <= 20 ? 'warning' : 'waiting';
          return { 
            countdown: formatCountdownSimple(refreshInfo.refreshTime), 
            status: status, 
            nextRefresh: refreshInfo.refreshTime 
          };
        } else if (now.getTime() === refreshInfo.refreshTime.getTime()) {
          return { 
            countdown: 'åˆ·æ–°ä¸­', 
            status: 'warning', 
            nextRefresh: refreshInfo.refreshTime 
          };
        } else {
          return { 
            countdown: 'å·²è¿‡æœŸ', 
            status: 'expired', 
            nextRefresh: refreshInfo.refreshTime 
          };
        }
      } else {
        // æ—¶é—´èŒƒå›´
        if (now < refreshInfo.earliest) {
          const diff = refreshInfo.earliest - now;
          const totalSeconds = Math.floor(diff / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const status = minutes <= 20 ? 'warning' : 'waiting';
          return { 
            countdown: formatCountdownSimple(refreshInfo.earliest), 
            status: status, 
            nextRefresh: refreshInfo.earliest 
          };
        } else if (now <= refreshInfo.latest) {
          return { 
            countdown: 'åˆ·æ–°ä¸­', 
            status: 'warning', 
            nextRefresh: refreshInfo.earliest 
          };
        } else {
          return { 
            countdown: 'å·²è¿‡æœŸ', 
            status: 'expired', 
            nextRefresh: refreshInfo.earliest 
          };
        }
      }
    }

    // æ ¼å¼åŒ–å€’è®¡æ—¶ï¼ˆåªæ˜¾ç¤ºæ—¶é—´ï¼Œä¸æ˜¾ç¤ºæ—¥æœŸï¼‰
    function formatCountdownSimple(targetTime) {
      if (!targetTime) return '---';
      
      const now = new Date();
      const diff = targetTime - now;

      if (diff <= 0) {
        return '00:00:00';
      }

      const totalSeconds = Math.floor(diff / 1000);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;

      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    // æ ¼å¼åŒ–åˆ·æ–°æ—¶é—´æ˜¾ç¤º
    function formatRefreshTimeDisplay(boss) {
      if (!boss.lastKillTime) return 'æœªè®°å½•å‡»æ€';
      
      const refreshInfo = calculateRefreshTime(boss);
      
      if (!refreshInfo.hasRange) {
        // ç²¾ç¡®æ—¶é—´
        const refreshTime = refreshInfo.refreshTime.toLocaleTimeString('zh-CN', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        });
        const indicator = boss.accuracy === 'accurate' ? 'ï¼ˆå‡†ï¼‰' : 'ï¼ˆä¼°ï¼‰';
        return `${refreshTime}${indicator}`;
      } else {
        // æ—¶é—´èŒƒå›´
        const earliestTime = refreshInfo.earliest.toLocaleTimeString('zh-CN', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        });
        const latestTime = refreshInfo.latest.toLocaleTimeString('zh-CN', {
          hour: '2-digit',
          minute: '2-digit',
          hour12: false
        });
        const indicator = boss.accuracy === 'accurate' ? 'ï¼ˆå‡†ï¼‰' : 'ï¼ˆä¼°ï¼‰';
        return `${earliestTime} - ${latestTime}${indicator}`;
      }
    }

    // æ¸²æŸ“ Boss åˆ—è¡¨
    function renderBossList() {
      const now = new Date();
      document.getElementById('currentTime').textContent = `å½“å‰æ—¶é—´ï¼š${now.toLocaleString('zh-CN', { 
        year: 'numeric', 
        month: '2-digit', 
        day: '2-digit', 
        hour: '2-digit', 
        minute: '2-digit',
        second: '2-digit',
        hour12: false 
      })}`;

      const content = document.getElementById('bossListContent');
      
      if (bosses.length === 0) {
        content.innerHTML = `
          <div class="empty-state">
            <h3>æš‚æ—  Boss æ•°æ®</h3>
            <p>æ·»åŠ  Boss å¼€å§‹è¿½è¸ªåˆ·æ–°æ—¶é—´</p>
          </div>
        `;
        return;
      }

      // è®¡ç®—æ¯ä¸ª Boss çš„çŠ¶æ€å’Œæ’åºæƒé‡
      const bossWithStatus = bosses.map(boss => {
        const countdownInfo = getCurrentCountdownStatus(boss);
        const refreshInfo = calculateRefreshTime(boss);
        
        // æ’åºæƒé‡ï¼šæœªè®°å½•æ­»äº¡æ—¶é—´çš„æ’æœ€åï¼Œå…¶ä»–æŒ‰æœ€æ—©åˆ·æ–°æ—¶é—´æ’åº
        let sortWeight;
        if (!boss.lastKillTime) {
          sortWeight = Infinity;
        } else if (countdownInfo.status === 'warning') {
          sortWeight = 0; // è­¦å‘ŠçŠ¶æ€çš„æ’æœ€å‰
        } else {
          const nextRefresh = refreshInfo.hasRange ? refreshInfo.earliest : refreshInfo.refreshTime;
          sortWeight = nextRefresh ? nextRefresh.getTime() : Infinity;
        }
        
        return { 
          ...boss, 
          ...countdownInfo, 
          sortWeight 
        };
      });

      // æŒ‰æ’åºæƒé‡å‡åºæ’åˆ—
      bossWithStatus.sort((a, b) => a.sortWeight - b.sortWeight);

      content.innerHTML = bossWithStatus.map(boss => {
        // æ ¼å¼åŒ–é—´éš”æ˜¾ç¤º
        const intervalText = boss.interval === 1 ? '1h' : `${boss.interval}h`;
        const delayText = boss.delay === 0 ? '' : `Â±${boss.delay}m`;
        const configText = delayText ? `${intervalText}ï¼Œ${delayText}` : intervalText;
        const nameConfig = `${boss.name}ï¼ˆé—´éš”${configText}ï¼‰`;
        
        const lastKillText = boss.lastKillTime ? 
          `å‡»æ€: ${new Date(boss.lastKillTime).toLocaleTimeString('zh-CN', {hour12: false})}` : 
          '';
          
        const refreshTimeText = formatRefreshTimeDisplay(boss);
        
        const accuracyClass = boss.accuracy === 'accurate' ? 'accuracy-accurate' : 'accuracy-estimate';
        const accuracyText = boss.accuracy === 'accurate' ? 'å‡†' : 'ä¼°';
        const accuracyIndicator = boss.lastKillTime ? `<span class="accuracy-indicator ${accuracyClass}">${accuracyText}</span>` : '';
          
        return `
        <div class="boss-item">
          <div class="boss-info">
            <div class="boss-header">
              <div class="boss-category ${boss.category}">${boss.category}</div>
              <div class="boss-name-config">${nameConfig}${accuracyIndicator}</div>
            </div>
            ${lastKillText ? `<div class="last-kill">${lastKillText}</div>` : ''}
          </div>
          <div class="refresh-countdown">
            <div class="refresh-time">${refreshTimeText}</div>
            <div class="countdown ${boss.status}">${boss.countdown}</div>
          </div>
          <div class="actions">
            <button class="btn btn-warning" onclick="recordKill(${boss.id})">å¿«é€Ÿè®°å½•</button>
            <button class="btn btn-primary" onclick="openTimeModal(${boss.id})">æ‰‹åŠ¨è®°å½•</button>
          </div>
        </div>
      `;
      }).join('');
    }

    // è®°å½•å½“å‰æ—¶é—´å‡»æ€
    async function recordKill(id) {
      const now = new Date();
      const bossIndex = bosses.findIndex(b => b.id === id);
      if (bossIndex !== -1) {
        const killTime = now.toISOString();
        
        // æ›´æ–°å†…å­˜æ•°æ®
        bosses[bossIndex].lastKillTime = killTime;
        bosses[bossIndex].accuracy = 'accurate';
        
        try {
          // ä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨å­˜å‚¨
          const success = await window.ServerDataManager.addKillRecord(id, killTime, 'accurate', 'ç”¨æˆ·');
          
          if (!success && !window.ServerDataManager.isConnected) {
            // æœåŠ¡å™¨å¤±è´¥ä¸”æœªè¿æ¥ï¼Œä½¿ç”¨æœ¬åœ°å­˜å‚¨
            DataStorage.saveBossConfigs(bosses);
            DataStorage.addKillRecord(id, killTime, 'accurate');
          }
          
        } catch (error) {
          console.error('è®°å½•å‡»æ€å¤±è´¥:', error);
          // é™çº§åˆ°æœ¬åœ°å­˜å‚¨
          DataStorage.saveBossConfigs(bosses);
          DataStorage.addKillRecord(id, killTime, 'accurate');
        }
        
        renderBossList();
      }
    }

    // æ‰“å¼€æ—¶é—´è¾“å…¥æ¨¡æ€æ¡†
    function openTimeModal(bossId) {
      currentEditingBossId = bossId;
      const modal = document.getElementById('timeModal');
      const dateTimeInput = document.getElementById('modalDateTime');
      
      // è®¾ç½®é»˜è®¤æ—¶é—´ä¸ºå½“å‰æ—¶é—´
      const now = new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      dateTimeInput.value = `${year}-${month}-${day}T${hours}:${minutes}`;
      
      // é‡ç½®å•é€‰æŒ‰é’®
      document.getElementById('modalAccuracyAccurate').checked = true;
      
      modal.style.display = 'block';
    }

    // å…³é—­æ¨¡æ€æ¡†
    function closeModal() {
      document.getElementById('timeModal').style.display = 'none';
      currentEditingBossId = null;
    }

    // ä¿å­˜æ¨¡æ€æ¡†ä¸­çš„æ—¶é—´
    function saveModalTime() {
      const dateTimeInput = document.getElementById('modalDateTime');
      const accuracy = document.querySelector('input[name="modalAccuracy"]:checked').value;
      
      if (!dateTimeInput.value) {
        alert('è¯·é€‰æ‹©æ—¶é—´');
        return;
      }
      
      const selectedDateTime = new Date(dateTimeInput.value);
      if (isNaN(selectedDateTime.getTime())) {
        alert('æ—¶é—´æ ¼å¼ä¸æ­£ç¡®');
        return;
      }
      
      processTimeInput(currentEditingBossId, selectedDateTime, accuracy);
      closeModal();
      renderBossList();
    }

    // å¤„ç†æ—¶é—´è¾“å…¥é€»è¾‘
    async function processTimeInput(bossId, selectedDateTime, accuracy) {
      const bossIndex = bosses.findIndex(b => b.id === bossId);
      if (bossIndex === -1) return;
      
      const killTime = selectedDateTime.toISOString();
      
      // æ›´æ–°å†…å­˜æ•°æ®
      bosses[bossIndex].lastKillTime = killTime;
      bosses[bossIndex].accuracy = accuracy;
      
      try {
        // ä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨å­˜å‚¨
        const success = await window.ServerDataManager.addKillRecord(bossId, killTime, accuracy, 'ç”¨æˆ·');
        
        if (!success && !window.ServerDataManager.isConnected) {
          // æœåŠ¡å™¨å¤±è´¥ä¸”æœªè¿æ¥ï¼Œä½¿ç”¨æœ¬åœ°å­˜å‚¨
          DataStorage.saveBossConfigs(bosses);
          DataStorage.addKillRecord(bossId, killTime, accuracy);
        }
        
      } catch (error) {
        console.error('å¤„ç†æ—¶é—´è¾“å…¥å¤±è´¥:', error);
        // é™çº§åˆ°æœ¬åœ°å­˜å‚¨
        DataStorage.saveBossConfigs(bosses);
        DataStorage.addKillRecord(bossId, killTime, accuracy);
      }
    }

    // å®æ—¶æ›´æ–°
    function startTimer() {
      renderBossList();
      setInterval(renderBossList, 1000);
    }

    // æ•°æ®å¯¼å‡ºåŠŸèƒ½
    function exportData() {
      const data = DataStorage.exportData();
      
      // åˆ›å»ºä¸‹è½½é“¾æ¥
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `boss_timer_backup_${new Date().toISOString().slice(0, 10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('æ•°æ®å¯¼å‡ºæˆåŠŸï¼');
    }

    // æ˜¾ç¤ºå¯¼å…¥æ¨¡æ€æ¡†
    function showImportModal() {
      document.getElementById('importModal').style.display = 'block';
      document.getElementById('importData').value = '';
    }

    // å…³é—­å¯¼å…¥æ¨¡æ€æ¡†
    function closeImportModal() {
      document.getElementById('importModal').style.display = 'none';
    }

    // æ‰§è¡Œæ•°æ®å¯¼å…¥
    function importData() {
      const importText = document.getElementById('importData').value.trim();
      
      if (!importText) {
        alert('è¯·è¾“å…¥è¦å¯¼å…¥çš„æ•°æ®');
        return;
      }
      
      if (DataStorage.importData(importText)) {
        // é‡æ–°åŠ è½½æ•°æ®
        bosses = DataStorage.getBossConfigs();
        renderBossList();
        closeImportModal();
        alert('æ•°æ®å¯¼å…¥æˆåŠŸï¼');
      } else {
        alert('æ•°æ®å¯¼å…¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ•°æ®æ ¼å¼æ˜¯å¦æ­£ç¡®');
      }
    }

    // æ˜¾ç¤ºé‡ç½®æ¨¡æ€æ¡†
    function showResetModal() {
      document.getElementById('resetModal').style.display = 'block';
    }

    // å…³é—­é‡ç½®æ¨¡æ€æ¡†
    function closeResetModal() {
      document.getElementById('resetModal').style.display = 'none';
    }

    // æ‰§è¡Œæ•°æ®é‡ç½®
    function resetData() {
      if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼')) {
        DataStorage.clearAllData();
        DataStorage.initData();
        bosses = DataStorage.getBossConfigs();
        renderBossList();
        closeResetModal();
        alert('æ•°æ®å·²é‡ç½®ä¸ºé»˜è®¤çŠ¶æ€');
      }
    }

    // é¡µé¢åŠ è½½
    window.addEventListener('load', async () => {
      await loadData();
      startTimer();
    });

    // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
    window.onclick = function(event) {
      const timeModal = document.getElementById('timeModal');
      const importModal = document.getElementById('importModal');
      const resetModal = document.getElementById('resetModal');
      
      if (event.target === timeModal) {
        closeModal();
      } else if (event.target === importModal) {
        closeImportModal();
      } else if (event.target === resetModal) {
        closeResetModal();
      }
    }
  </script>
</body>
</html>

